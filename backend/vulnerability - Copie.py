from fastapi import FastAPI
from fastapi.responses import FileResponse
import os
from fastapi import APIRouter
router = APIRouter()
import asyncio

# vulnerability.py
# vulnerability.py
import asyncio
from typing import List, Dict, Any
from fastapi import APIRouter, FastAPI
from fastapi.responses import JSONResponse
import httpx
from cvss import CVSS3  # pip install cvss
import requests
import platform

try:
    from importlib.metadata import distributions
except ImportError:
    from importlib_metadata import distributions

router = APIRouter()
CVE_LIMIT_PER_PKG = 5  # max CVEs per package


def cvss_to_severity(score: float) -> str:
    if score >= 9.0:
        return "CRITICAL"
    elif score >= 7.0:
        return "HIGH"
    elif score >= 4.0:
        return "MEDIUM"
    elif score > 0:
        return "LOW"
    else:
        return "UNKNOWN"


# -------------------------
# Python packages (PyPI) via OSV
# -------------------------
async def detect_pip_packages() -> List[Dict[str, str]]:
    pkgs = []
    for dist in distributions():
        pkgs.append({"name": dist.metadata["Name"], "version": dist.version})
    return pkgs


async def query_osv_for_package(client: httpx.AsyncClient, pkg: Dict[str, str]) -> List[Dict[str, Any]]:
    payload = {"package": {"name": pkg["name"], "ecosystem": "PyPI"}}
    try:
        resp = await client.post("https://api.osv.dev/v1/query", json=payload, timeout=15)
        data = resp.json()
        vulns = []

        for v in (data.get("vulns") or [])[:CVE_LIMIT_PER_PKG]:
            score_val = None
            severity = "UNKNOWN"

            # Check CVSS entries
            for cvss_item in v.get("cvss", []):
                if "baseScore" in cvss_item and cvss_item["baseScore"] is not None:
                    score_val = float(cvss_item["baseScore"])
                    severity = cvss_to_severity(score_val)
                    break
                vector = cvss_item.get("vectorString") or cvss_item.get("vector")
                if vector:
                    try:
                        cvss_obj = CVSS3(vector)
                        score_val = round(cvss_obj.scores()[0], 1)
                        severity = cvss_to_severity(score_val)
                        break
                    except Exception:
                        continue

            if score_val is None:
                db_spec = v.get("database_specific", {})
                if "cvssScore" in db_spec:
                    try:
                        score_val = float(db_spec["cvssScore"])
                        severity = cvss_to_severity(score_val)
                    except Exception:
                        pass
                elif "cvss" in db_spec:
                    try:
                        cvss_obj = CVSS3(db_spec["cvss"])
                        score_val = round(cvss_obj.scores()[0], 1)
                        severity = cvss_to_severity(score_val)
                    except Exception:
                        pass
                elif "severity" in db_spec:
                    severity = db_spec.get("severity", "UNKNOWN")

            if score_val is None:
                score_val = "N/A"

            vulns.append({
                "package": pkg["name"],
                "version": pkg["version"],
                "cveId": v.get("id", "N/A"),
                "severity": severity,
                "score": score_val,
                "description": v.get("summary", "")
            })

        return vulns
    except Exception as e:
        return [{
            "package": pkg["name"],
            "version": pkg["version"],
            "cveId": "ERROR",
            "severity": "ERROR",
            "score": "N/A",
            "description": str(e)
        }]


# -------------------------
# Windows / System packages via NVD API
# -------------------------
def query_cve_nvd(keyword: str) -> List[Dict[str, Any]]:
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keyword={keyword}"
    try:
        r = requests.get(url, timeout=10)
        r.raise_for_status()
        data = r.json()
        vulns = []

        for item in data.get("vulnerabilities", [])[:CVE_LIMIT_PER_PKG]:
            cve_id = item["cve"]["id"]
            severity = "UNKNOWN"
            score_val = "N/A"

            metrics = item["cve"].get("metrics", {})
            for metric_type in metrics:
                # Try CVSS v3.1
                cvss_list = metrics[metric_type].get("cvssMetricV31", [])
                if cvss_list:
                    base_score = cvss_list[0].get("cvssData", {}).get("baseScore")
                    if base_score is not None:
                        score_val = float(base_score)
                        severity = cvss_to_severity(score_val)
                        break

            vulns.append({
                "package": keyword,
                "version": platform.version(),
                "cveId": cve_id,
                "severity": severity,
                "score": score_val,
                "description": item["cve"].get("descriptions", [{}])[0].get("value", "")
            })

        return vulns

    except Exception as e:
        return [{
            "package": keyword,
            "version": platform.version(),
            "cveId": "ERROR",
            "severity": "ERROR",
            "score": "N/A",
            "description": str(e)
        }]


# -------------------------
# API Endpoint
# -------------------------
@router.get("/api/vulnerabilities")
async def get_vulnerabilities():
    packages = await detect_pip_packages()
    to_query = packages[:20]

    async with httpx.AsyncClient() as client:
        tasks = [query_osv_for_package(client, pkg) for pkg in to_query]
        python_results = await asyncio.gather(*tasks)

    python_vulns = [item for sublist in python_results for item in sublist]

    # System / Windows vulnerabilities
    system_vulns = query_cve_nvd("Windows")  # Change keyword to scan Linux / OS packages if needed

    # Merge both
    vulns = python_vulns + system_vulns

    return JSONResponse(content={"vulns": vulns, "scanned_packages_count": len(packages)})



 

@router.get("/api/cpu_threads2")
def get_cpu_threads():
    cpu_info = []
    for i, times in enumerate(psutil.cpu_times(percpu=True)):
        cpu_info.append({
            "core": i,
            "user": times.user,
            "system": times.system,
            "idle": times.idle
        })
    return {"cores": cpu_info}



# Serve index.html
@router.get("/")
def read_index():
    return FileResponse(os.path.join("static", "index.html"))

# Serve vulnerability.html
@router.get("/vulnerability")
def read_vulnerability():
    return FileResponse(os.path.join("static", "vulnerability.html"))
